import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'function/word_generator.dart';
import 'widget/heading.dart';
import 'widget/text_label.dart';

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  // 0 Vowel, 1 Consonant, 2 Random
  var types = "012";
  var maxCharPerLine = 160;
  var minChar = 4;
  var errorTolerance = 30;
  List<String> combinedWords = [];
  List<String> validWords = [];
  var isCallingApi = false;
  var currentFetchIndex = 0;
  var validWordLimit = 5;
  var wordLimit = 500;

  late final SharedPreferences prefs;
  final List<String> savedTexts = [];

  // final StreamController<String> _validStream = StreamController<String>();
  final StreamController<String> _generatedStream = StreamController<String>();

  final TextEditingController validWordLimitController =
      TextEditingController();
  final TextEditingController minCharController = TextEditingController();

  @override
  void dispose() {
    _generatedStream.close();
    super.dispose();
  }

  Future<void> generateWords(String inputText) async {
    combinedWords = [];
    validWords = [];
    // _validStream.sink.add("");
    currentFetchIndex = 0;
    streamWords(inputText.toUpperCase(), minChar, errorTolerance, wordLimit,
        combinedWords, _generatedStream);
  }

  Future<void> saveTextToPreferences(String text) async {
    if (savedTexts.contains(text)) {
      savedTexts.remove(text);
    } else {
      savedTexts.add(text);
    }
    await prefs.setStringList('savedTexts', savedTexts);
  }

  Future<void> removeTextFromPreferences(String text) async {
    savedTexts.remove(text);
    await prefs.setStringList('savedTexts', savedTexts);
  }

  @override
  void initState() {
    super.initState();
    loadSharedPreference();
  }

  @override
  Widget build(BuildContext context) {
    validWordLimitController.text = validWordLimit.toString();
    minCharController.text = minChar.toString();
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(16.0), // Add padding to screen corners
        child: SingleChildScrollView(
          // Wrap with SingleChildScrollView
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            // Align left components
            children: [
              Container(
                padding: EdgeInsets.only(top: 8.0),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment
                      .spaceEvenly, // Adjust alignment as needed
                  children: [
                    Flexible(
                      child: TextField(
                        decoration: const InputDecoration(
                          labelText: 'Karakter',
                        ),
                        onSubmitted: (value) async {
                          await generateWords(value);
                          // _startStream();
                        },
                      ),
                    ),
                    SizedBox(width: 8.0), // Add spacing between the text fields
                    Flexible(
                      child: TextField(
                        controller: minCharController,
                        decoration: const InputDecoration(
                          labelText: 'Minimal Karakter',
                          hintText: 'Enter minimum char generated by words',
                        ),
                        onChanged: (text) {
                          if (text.isNotEmpty) {
                            minChar = int.tryParse(text) ?? minChar;
                          }
                        },
                        keyboardType: TextInputType.number,
                        inputFormatters: <TextInputFormatter>[
                          FilteringTextInputFormatter.digitsOnly,
                        ],
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 16.0), // Add spacing before headings
              const Heading('Kata Random'),
              const SizedBox(height: 8.0), // Add space before heading

              StreamBuilder<String>(
                stream: _generatedStream.stream,
                builder: (context, snapshot) {
                  if (snapshot.hasData) {
                    return WrappedLayout(
                      children: combinedWords.map((word) {
                        final isSaved = savedTexts.contains(word);
                        return GestureDetector(
                          onTap: () {
                            if (!isSaved) {
                              saveTextToPreferences(word);
                            } else {
                              removeTextFromPreferences(word);
                            }
                            _generatedStream.sink.add("");
                          },
                          child: TextLabel(
                            text: word,
                            backgroundColor:
                                isSaved ? Colors.green : Colors.grey,
                            padding: EdgeInsets.all(8.0),
                          ),
                        );
                      }).toList(),
                    );
                  } else {
                    return const Text(
                      'No words generated yet',
                      style: TextStyle(color: Colors.grey),
                    );
                  }
                },
              )
            ],
          ),
        ),
      ),
    );
  }

  Future<void> loadSharedPreference() async {
    prefs = await SharedPreferences.getInstance();
    savedTexts.addAll(prefs.getStringList('savedTexts') ?? []);
  }
}

class WrappedLayout extends StatelessWidget {
  final List<Widget> children;

  const WrappedLayout({super.key, required this.children});

  @override
  Widget build(BuildContext context) {
    return Wrap(runSpacing: -.1, spacing: -.1, children: children);
  }
}
